(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{455:function(a,s,t){"use strict";t.r(s);var e=t(46),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"babel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#babel"}},[a._v("#")]),a._v(" Babel")]),a._v(" "),t("p",[a._v("Babel 是一个 JavaScript 编译器，可以将编写的代码处理成向后兼容的 JavaScript 语法。")]),a._v(" "),t("h3",{attrs:{id:"处理流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#处理流程"}},[a._v("#")]),a._v(" 处理流程")]),a._v(" "),t("ul",[t("li",[a._v("Tokenizer：词法分析，将代码分割成 Token 数组；")]),a._v(" "),t("li",[a._v("Parser：语法分析，将 Token 数组转换成 AST；")]),a._v(" "),t("li",[a._v("Traverser：遍历 AST，加载转换器；")]),a._v(" "),t("li",[a._v("Transform：使用转换器，增删改查 AST 节点；")]),a._v(" "),t("li",[a._v("Generator：将 AST 转换回代码。")])]),a._v(" "),t("h2",{attrs:{id:"gulp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gulp"}},[a._v("#")]),a._v(" Gulp")]),a._v(" "),t("p",[a._v("是一个基于流的自动化构建工具，不包括模块化的功能，通过配置一系列的 task，例如文件压缩合并、雪碧图、启动 server、版本控制等，然后定义执行顺序来执行 task，从而构建前端项目的流程。")]),a._v(" "),t("p",[a._v("gulp 强调的是规范前端开发的流程，功能类似于 webpack 的插件功能。")]),a._v(" "),t("h3",{attrs:{id:"核心"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心"}},[a._v("#")]),a._v(" 核心")]),a._v(" "),t("ul",[t("li",[a._v("task: 创建一个任务")]),a._v(" "),t("li",[a._v("series：顺序执行多个任务")]),a._v(" "),t("li",[a._v("parallel：并行执行多个任务")]),a._v(" "),t("li",[a._v("src：读取数据源转换成 stream")]),a._v(" "),t("li",[a._v("pipe：管道-可以在中间对数据流进行处理")]),a._v(" "),t("li",[a._v("dest：输出数据流到目标路径")]),a._v(" "),t("li",[a._v("on：事件监听")]),a._v(" "),t("li",[a._v("watch：数据源监听")])]),a._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),t("p",[a._v("核心就是把文件转换成 Node 中的 Stream 流，然后对 Stream 进行操作。")]),a._v(" "),t("p",[a._v("gulp 采用 pipe（管道）的概念，意味着顺着管道流淌，插件就相当于在管道中间有个过滤站，对流进行过滤处理。")]),a._v(" "),t("h3",{attrs:{id:"最佳实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[a._v("#")]),a._v(" 最佳实践")]),a._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v(".")]),a._v("\n├── gulpfile.js\n├── package.json\n└── workflow\n    ├── common.js\n    ├── lib.js\n    └── task\n        ├── clean.js\n        ├── compass.js\n        ├── include.js\n        ├── initProject.js\n        ├── merge.js\n        ├── readToolMethod.js\n        ├── start.js\n        ├── version.js\n        └── watch.js\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br")])]),t("h2",{attrs:{id:"webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[a._v("#")]),a._v(" Webpack")]),a._v(" "),t("h3",{attrs:{id:"是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[a._v("#")]),a._v(" 是什么")]),a._v(" "),t("p",[a._v("一个静态模块打包工具，可以将不同类型的模块处理成 JS 模块，并且对模块进行一定的处理。")]),a._v(" "),t("h3",{attrs:{id:"核心概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心概念"}},[a._v("#")]),a._v(" 核心概念")]),a._v(" "),t("ul",[t("li",[a._v("入口 (entry)")]),a._v(" "),t("li",[a._v("输出 (output)")]),a._v(" "),t("li",[a._v("loader")]),a._v(" "),t("li",[a._v("插件 (plugin)")])]),a._v(" "),t("h3",{attrs:{id:"解决了什么问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决了什么问题"}},[a._v("#")]),a._v(" 解决了什么问题")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("编译兼容")]),a._v("：ES Modules 模块系统本身就存在环境兼容问题；")]),a._v(" "),t("li",[t("strong",[a._v("模块打包")]),a._v("：每一个模块都需要单独从服务器请求回来，影响性能；")]),a._v(" "),t("li",[t("strong",[a._v("能力拓展")]),a._v("：除了 JS，还有其他类型的模块；")])]),a._v(" "),t("p",[a._v("前两个问题，Gulp 之类的工具也可以解决，第三个只能使用 webpack。")]),a._v(" "),t("h3",{attrs:{id:"打包流程-运行原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包流程-运行原理"}},[a._v("#")]),a._v(" 打包流程/运行原理")]),a._v(" "),t("ol",[t("li",[a._v("读取 webpack 的配置参数；")]),a._v(" "),t("li",[a._v("启动 webpack，创建 Compiler 对象控制流程，Compilation 对象解析项目；")]),a._v(" "),t("li",[a._v("从入口文件 (entry) 开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；")]),a._v(" "),t("li",[a._v("对不同文件类型的依赖模块文件使用对应的 Loader 进行编译，最终转为 Javascript 文件；")]),a._v(" "),t("li",[a._v("整个过程中 webpack 会通过发布订阅模式，向外抛出一些 hooks，而 webpack 的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。")])]),a._v(" "),t("p",[a._v("每个模块间的依赖关系，依赖于 AST 语法树。每个模块文件在通过 Loader 解析完成之后，会通过 acorn 库生成模块代码的 AST 语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。")]),a._v(" "),t("p",[a._v("最终 Webpack 打包出来的 bundle 文件是一个 IIFE （立即执行的函数表达式）。")]),a._v(" "),t("h3",{attrs:{id:"loader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loader"}},[a._v("#")]),a._v(" Loader")]),a._v(" "),t("p",[a._v("Webpack 内部只能够处理 JS 模块代码，Loader 负责类型转换，将其他类型的模块转化为 JS 代码模块。")]),a._v(" "),t("p",[a._v("针对每个文件类型，loader 是支持以数组的形式配置多个的，因此当 Webpack 在转换该文件类型的时候，会按顺序链式调用每一个 loader，前一个 loader 返回的内容会作为下一个 loader 的入参。因此 loader 的开发需要遵循一些规范，比如返回值必须是标准的 JS 代码字符串，以保证下一个 loader 能够正常工作。")]),a._v(" "),t("ul",[t("li",[a._v("单一原则：每个 Loader 只做一件事；")]),a._v(" "),t("li",[a._v("链式调用：Webpack 会按顺序链式调用每个 Loader；")]),a._v(" "),t("li",[a._v("统一原则：遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；")])]),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),t("p",[a._v("同一类型模块使用多个 loader 处理时，从后往前调用。")])]),a._v(" "),t("p",[a._v("常用：")]),a._v(" "),t("ul",[t("li",[a._v("image-loader：加载并且压缩图⽚⽂件")]),a._v(" "),t("li",[a._v("babel-loader：把 ES6 转换成 ES5")]),a._v(" "),t("li",[a._v("css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性")]),a._v(" "),t("li",[a._v("style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。")])]),a._v(" "),t("h3",{attrs:{id:"plugin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugin"}},[a._v("#")]),a._v(" Plugin")]),a._v(" "),t("p",[a._v("webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务，从而实现自己想要的功能。")]),a._v(" "),t("p",[a._v("Plugin 的开发和开发 Loader 一样，需要遵循一些开发上的规范和原则：")]),a._v(" "),t("ul",[t("li",[a._v("插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例；")]),a._v(" "),t("li",[a._v("传给每个插件的 compiler 和 compilation 对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件；")]),a._v(" "),t("li",[a._v("异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住；")])]),a._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MyPlugin")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apply")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("compiler")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 找到合适的事件钩子，实现自己的插件功能")]),a._v("\n    compiler"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("hooks"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("emit"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("tap")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'MyPlugin'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("compilation")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// compilation: 当前打包构建流程的上下文")]),a._v("\n      console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("compilation"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// do something...")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br")])]),t("p",[a._v("常用 plugin：")]),a._v(" "),t("ul",[t("li",[a._v("html-webpack-plugin：可以根据模板自动生成 html 代码，并自动引用 css 和 js 文件。")]),a._v(" "),t("li",[a._v("webpack-bundle-analyzer：可视化 Webpack 输出文件的体积（业务组件、依赖第三方模块）。")])]),a._v(" "),t("h3",{attrs:{id:"sourcemap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sourcemap"}},[a._v("#")]),a._v(" sourceMap")]),a._v(" "),t("p",[a._v("对应 Webpack 配置里边的 devtool 字段。")]),a._v(" "),t("p",[a._v("sourceMap 是一项将编译、打包、压缩后的代码映射回源代码的技术。打包压缩后的代码可读性很差，不好调试，sourceMap 可以帮助我们快速定位到源代码的位置，提高开发效率。")]),a._v(" "),t("p",[a._v("sourceMap 其实并不是 Webpack 特有的功能，而是 Webpack 支持 sourceMap，像 JQuery 也支持 sourceMap。")]),a._v(" "),t("p",[t("strong",[a._v("原理")]),a._v("：VLQ (Variable-length quantity)，一种编码方式，使用任意位数的二进制来表示一个任意大的数字。特点就是可以非常精简地表示很大的数值，用来节省空间。webpack 中打包之后每个文件模块，都有一个对应的"),t("code",[a._v(".map")]),a._v("文件，里面存放着他们的源码路径。")]),a._v(" "),t("h3",{attrs:{id:"热更新原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#热更新原理"}},[a._v("#")]),a._v(" 热更新原理")]),a._v(" "),t("p",[a._v("其实是本地起了一个 express 应用，添加了对 webpack 编译的监听，添加了和浏览器的 websocket 长连接，当文件变化触发 webpack 编译触发监听后，会通过 socket 消息告诉浏览器准备刷新。而为了减少刷新的代价，就是不用刷新网页，而是刷新某个模块，webpack-dev-server 通过生成文件的 hash 值来比对需要更新的模块，浏览器再进行替换。")]),a._v(" "),t("h3",{attrs:{id:"懒加载原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#懒加载原理"}},[a._v("#")]),a._v(" 懒加载原理")]),a._v(" "),t("p",[a._v("在打包时会将懒加载的代码切割出去单独打包，然后在主包中进行按需加载，最后执行调用。")]),a._v(" "),t("h3",{attrs:{id:"tree-shaking-原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking-原理"}},[a._v("#")]),a._v(" Tree Shaking 原理")]),a._v(" "),t("p",[a._v("利用 es6 模块的规范")]),a._v(" "),t("ul",[t("li",[a._v("ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块")]),a._v(" "),t("li",[a._v("静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码")])]),a._v(" "),t("h3",{attrs:{id:"如何用webpack-来优化前端性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何用webpack-来优化前端性能"}},[a._v("#")]),a._v(" 如何⽤webpack 来优化前端性能？")]),a._v(" "),t("ul",[t("li",[a._v("压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。UglifyJsPlugin 压缩 JS⽂件，利⽤ cssnano 压缩 css；")]),a._v(" "),t("li",[a._v("利⽤ CDN 加速：在构建过程中，将引⽤的静态资源路径修改为 CDN 上对应的路径；")]),a._v(" "),t("li",[a._v("Tree Shaking: 将代码中永远不会⾛到的⽚段删除掉。追加参数 --optimize-minimize 来实现；")]),a._v(" "),t("li",[a._v("Code Splitting: 将代码按路由维度或者组件分块 (chunk), 这样做到按需加载，同时可以充分利⽤浏览器缓存；")])]),a._v(" "),t("h3",{attrs:{id:"调试技巧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调试技巧"}},[a._v("#")]),a._v(" 调试技巧")]),a._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6943468761575849992",target:"_blank",rel:"noopener noreferrer"}},[a._v("当面试官问 Webpack 的时候他想知道什么"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/7023242274876162084",target:"_blank",rel:"noopener noreferrer"}},[a._v("构建 webpack5.x 知识体系"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000016231512",target:"_blank",rel:"noopener noreferrer"}},[a._v("AST 抽象语法树——最基础的 javascript 重点知识，99%的人根本不了解"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000021494964",target:"_blank",rel:"noopener noreferrer"}},[a._v("撸一个简版的 Webpack"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=r.exports}}]);