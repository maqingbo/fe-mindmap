(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{449:function(v,_,t){"use strict";t.r(_);var a=t(46),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("这一部分内容不只限于前端开发，而是任何软件或系统的设计都要考虑到的。")])]),v._v(" "),t("p",[v._v("软件设计是一门关注长期变化的学问。初学编程的程序员会追求把一个功能实现出来，他无法看到一个软件长期的变化。")]),v._v(" "),t("p",[v._v("算法和软件设计其实是一样的，二者对抗的都是规模问题。"),t("strong",[v._v("算法对抗的是数据的规模，而软件设计对抗的是需求的规模")]),v._v("。数据达到一定规模之后，快速排序比插入排序才更有优势；需求达到一定规模之后，面向对象的编程范式会比面向过程更有优势。")]),v._v(" "),t("p",[v._v("软件设计的优劣在根本上决定了软件系统的质量。好的设计，可以让系统更容易修改和扩展，不好的设计，却会让人举步维艰。")]),v._v(" "),t("h2",{attrs:{id:"模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模型"}},[v._v("#")]),v._v(" 模型")]),v._v(" "),t("p",[v._v("软件开发的目的是什么？")]),v._v(" "),t("p",[v._v("是解决由需求带来的问题，解决的结果是一个可以运行的交付物。比如在线购物的需求，通过电商平台这个方案来解决。")]),v._v(" "),t("p",[v._v("软件设计，就是架通需求和解决方案的桥梁！")]),v._v(" "),t("p",[v._v("区别于解决简单的问题，软件的开发往往是一项长期的工作，会有许多人参与其中。在这种情况下，就需要建立起一个统一的结构，以便于所有人都能有一个共同的理解。这就如同建筑中的图纸，懂建筑的人看了之后，就会产生一个统一的认识。")]),v._v(" "),t("p",[v._v("在软件的开发过程中，这种统一的结构就是模型，而软件设计就是要"),t("strong",[v._v("构建出一套模型")]),v._v("。")]),v._v(" "),t("p",[v._v("模型，是一个软件的架构。")]),v._v(" "),t("ul",[t("li",[v._v("粒度上可大可小；")]),v._v(" "),t("li",[v._v("好的模型应该“高内聚、低耦合”；")]),v._v(" "),t("li",[v._v("模型可以分层，由底层的模型提供接口，构建出上层的模型。")])]),v._v(" "),t("h2",{attrs:{id:"规范"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#规范"}},[v._v("#")]),v._v(" 规范")]),v._v(" "),t("p",[v._v("规范，就是限定了什么样的需求应该以怎样的方式去完成。比如：")]),v._v(" "),t("ul",[t("li",[v._v("与业务处理相关的代码，应该体现在领域模型中；")]),v._v(" "),t("li",[v._v("与网络连接相关的代码，应该写在网关里；")]),v._v(" "),t("li",[v._v("与外部系统集成的代码，需要有防腐层；")]),v._v(" "),t("li",[v._v("......")])]),v._v(" "),t("p",[v._v("显式的、统一的规范可以使项目以一个统一的方式去进行，即便未来设计要演化、规范要调整，项目也要可控得多。")]),v._v(" "),t("h2",{attrs:{id:"分离关注点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分离关注点"}},[v._v("#")]),v._v(" 分离关注点")]),v._v(" "),t("p",[v._v("软件开发中最常见一种解决问题的方式就是“分而治之”。大系统拆解为模块，模块再拆分为小功能。值得注意的是，拆解时候要从多维度去考虑，每个维度代表一个关注点，这就是设计中常见的一个说法：分离关注点。")]),v._v(" "),t("p",[v._v("不同的关注点混合在一起可能会带来很多问题，另一方面，分离关注点有助于我们发现不同模块的共性，更好的进行设计。")]),v._v(" "),t("p",[v._v("常见的关注点混淆情况：")]),v._v(" "),t("ul",[t("li",[v._v("技术和业务混淆：\n"),t("ul",[t("li",[v._v("例子：上游系统以推送的方式向当前系统发消息，但是有可能会丢消息，于是开发人员加了一个补偿机制，来请求丢失的消息。业务量大的时候，补偿机制触发频繁，进一步加大服务器负担。问题点在于，推送消息是通信层面的问题，补偿机制将其带到了业务层面，更好的解决方案是选择一个吞吐量更大的消息队列。")])])]),v._v(" "),t("li",[v._v("不同数据变动方向的混淆：\n"),t("ul",[t("li",[v._v("在 Java 应用里，做数据库访问用 Spring Data JPA 好，还是 MyBatis 好。Spring Data JPA 简化了数据库访问，自动生成对应的 SQL 语句，而 MyBatis 则要自己手写 SQL。从本质上说，之所以出现工具选择的困难，是因为他把两种数据使用频率不同的场景混在一起所造成的。如果将前台访问（处理增删改查）和后台访问（统计报表）分开，纠结也就不复存在了。")])])]),v._v(" "),t("li",[v._v("......")])]),v._v(" "),t("h2",{attrs:{id:"软件的可测试性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件的可测试性"}},[v._v("#")]),v._v(" 软件的可测试性")]),v._v(" "),t("p",[v._v("需求的分类：")]),v._v(" "),t("ul",[t("li",[v._v("功能型需求")]),v._v(" "),t("li",[v._v("非功能型需求\n"),t("ul",[t("li",[v._v("执行质量：吞吐、延迟、安全等")]),v._v(" "),t("li",[v._v("演化质量：可测试性、可维护性、可拓展性等")])])])]),v._v(" "),t("p",[v._v("在这些分类中最容易被忽略的就是“可测试性”。")]),v._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/intro/100052601",target:"_blank",rel:"noopener noreferrer"}},[v._v("软件设计之美 - 极客时间"),t("OutboundLink")],1)]),v._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/354528902",target:"_blank",rel:"noopener noreferrer"}},[v._v("聊聊编程范式"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=r.exports}}]);