---
title: '学习 JavaScript 数据结构与算法'
---

# 学习 JavaScript 数据结构与算法（第 3 版）

## 本书结构

- 第 1 章：“JavaScript 简介”，讲述了 JavaScript 的基础知识。
- 第 2 章：“ECMAScript 和 TypeScript 概述”。
- 第 3 章：“数组”，介绍了如何使用数组这种最基础且最常用的数据结构。
- 第 4 章：“栈”，如何创建栈以及怎样添加和删除元素，如何用栈解决计算机科学中的一些问题。
- 第 5 章：“队列和双端队列”，如何创建队列，以及如何添加和删除队列中的元素。也介绍了一种特殊的队列——双端队列数据结构，以及栈和队列的主要区别。
- 第 6 章：“链表”，讲解如何用对象和指针从头创建链表这种数据结构。这一章除了讨论如何声明、创建、添加和删除链表元素之外，还介绍了不同类型的链表，例如双向链表和循环链表。
- 第 7 章：“集合”，介绍了集合这种数据结构，讨论了如何用集合存储非重复性的元素。此外，还详述了对集合的各种操作以及相应代码的实现。
- 第 8 章：“字典和散列表”，深入讲解字典、散列表及它们之间的区别。这一章介绍了这两种数据结构是如何声明、创建和使用的，还探讨了如何解决散列冲突，以及如何创建更高效的散列函数。
- 第 9 章：“递归”，介绍了递归的概念，描述了声明式和递归式算法之间的区别。
- 第 10 章：“树”，讲解了树这种数据结构和它的相关术语，重点讨论了二叉搜索树，以及如何在树中搜索、遍历、添加和删除节点。这一章还介绍了自平衡树，包括 AVL 树和红黑树。
- 第 11 章：“二叉堆和堆排序”，介绍了最小堆和最大堆数据结构，以及怎样使用堆作为一个优先队列，还讨论了著名的堆排序算法。
- 第 12 章：“图”，介绍了图这种数据结构和它的适用范围。这一章讲述了图的常用术语和不同表示方式，探讨了如何使用深度优先搜索算法和广度优先搜索算法遍历图，以及它们的适用范围。
- 第 13 章：“排序和搜索算法”，探讨了常用的排序算法，如冒泡排序（包括改进版）、选择排序、插入排序、归并排序和快速排序。这一章还介绍了计数排序和基数排序这两种分布式排序算法，搜索算法中的顺序搜索和二分搜索，以及怎样随机排列一个数组。
- 第 14 章：“算法设计与技巧”， 介绍了一些算法技巧和著名的算法，以及 JavaScript 函数式编程。
- 第 15 章：“算法复杂度”，介绍了大 O 表示法的概念，以及本书实现算法的复杂度列表。这一章还介绍了 NP 完全问题和启发式算法。最后，讲解了提升算法能力的诀窍。

## 第 1 章　JavaScript 简介

### 相等运算符（== 和 ===）

使用`==`时，不同类型的值也可以被看作相等。下面的表格展示了不同类型的值用相等运算符比较后的结果。

 | 类型（ x） | 类型（ y） | 结 果               |
 | ---------- | ---------- | ------------------- |
 | null       | undefined  | true                |
 | undefined  | null       | true                |
 | 数         | 字符串     | x == toNumber(y)    |
 | 字符串     | 数         | toNumber(x) == y    |
 | 布尔值     | 任何类型   | toNumber(x) == y    |
 | 任何类型   | 布尔值     | x == toNumber(y)    |
 | 字符串或数 | 对象       | x == toPrimitive(y) |
 | 对象       | 字符串或数 | toPrimitive(x) == y |

如果 x 和 y 的类型相同， JavaScript 会用 equals 方法比较这两个值或对象。没有列在这个表格中的其他情况都会返回 false。

toNumber 和 toPrimitive 方法是内部的，并根据以下表格对其进行估值。toNumber 方法对不同类型返回的结果如下。

| 值 类 型  | 结 果                                                                                                                                 |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| undefined | NaN                                                                                                                                   |
| null      | +0                                                                                                                                    |
| 布尔值    | 如果是 true，返回 1；如果是 false，返回+0                                                                                             |
| 数        | 数对应的值                                                                                                                            |
| 对象      | 如果对象的 valueOf 方法的结果是原始值，返回原始值；</br>如果对象的 toString 方法返回原始值，就返回这个值；</br>其他情况都返回一个错误 |

示例：

```js
console.log('packt' == true) // false

// 为什么输出是 false?
// 首先，布尔值会被 toNumber 方法转成数，因此得到 packt == 1。
// 其次，用 toNumber 转换字符串值。因为字符串包含字母，所以会被转成 NaN，
// 表达式就变成了 NaN == 1，结果就是 false。
```

那么`===`运算符呢？简单多了。如果比较的两个值类型不同，比较的结果就是 false。如果比较的两个值类型相同，结果会根据下表判断。

| 类型（ x） | 值                            | 结 果 |
| ---------- | ----------------------------- | ----- |
| 数         | x 和 y 的值相同（但不是 NaN） | true  |
| 字符串     | x 和 y 是相同的字符           | true  |
| 布尔值     | x 和 y 都是 true 或 false     | true  |
| 对象       | x 和 y 引用同一个对象         | true  |

## 第 2 章　ECMA Script 和 TypeScript 概述

没啥新鲜的，只是一个大概的介绍，略。

## 第 3 章　数组

数组存储一系列同一种数据类型的值。虽然在 JavaScript 里，也可以在数组中保存不同类型的值，但我们还是遵守最佳实践，避免这么做（大多数语言都没这个能力）。

紧接着介绍了数组常用的方法，也没啥好说的，略。

### ECMA Script 6 和数组的新功能

| 方 法      | 描 述                                                                      |
| ---------- | -------------------------------------------------------------------------- |
| @@iterator | 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对   |
| copyWithin | 复制数组中一系列元素到同一数组指定的起始位置                               |
| entries    | 返回包含数组所有键值对的 @@iterator                                        |
| includes   | 如果数组中存在某个元素则返回 true，否则返回 false。 E2016 新增             |
| find       | 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素               |
| findIndex  | 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引 |
| fill       | 用静态值填充数组                                                           |
| from       | 根据已有数组创建一个新数组                                                 |
| keys       | 返回包含数组所有索引的 @@iterator                                          |
| of         | 根据传入的参数创建一个新数组                                               |
| values     | 返回包含数组中所有值的 @@iterator                                          |



## 第 4 章　栈

栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。

## 第 5 章　队列和双端队列
## 第 6 章　链表
## 第 7 章　集合
## 第 8 章　字典和散列表
## 第 9 章　递归
## 第 10 章　树
## 第 11 章　二叉堆和堆排序
## 第 12 章　图
## 第 13 章　排序和搜索算法
## 第 14 章　算法设计与技巧
## 第 15 章　算法复杂度